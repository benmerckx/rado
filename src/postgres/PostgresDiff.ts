import {getTable, type HasSql} from '../core/Internal.ts'
import {sql} from '../core/Sql.ts'
import {alias, table, type Table} from '../core/Table.ts'
import {
  and,
  asc,
  eq,
  gt,
  isNotNull,
  like,
  ne,
  not,
  or,
  when
} from '../core/expr/Conditions.ts'
import type {Diff} from '../migrate/Diff.ts'
import {concat, txGenerator} from '../universal.ts'
import * as column from './PostgresColumns.ts'
import {postgresDialect} from './PostgresDialect.ts'

const PgAttribute = table('pg_attribute', {
  attname: column.text().notNull(),
  atttypid: column.oid().notNull(),
  atttypmod: column.integer().notNull(),
  attnotnull: column.boolean().notNull(),
  attrelid: column.oid().notNull(),
  attisdropped: column.boolean().notNull(),
  attnum: column.integer().notNull(),
  attidentity: column.text(),
  atthasdef: column.boolean().notNull()
})

const PgClass = table('pg_class', {
  oid: column.oid().notNull(),
  relname: column.text().notNull(),
  relnamespace: column.oid().notNull()
})

const PgNamespace = table('pg_namespace', {
  oid: column.oid().notNull(),
  nspname: column.text().notNull()
})

const PgType = table('pg_type', {
  oid: column.oid().notNull(),
  typname: column.text().notNull()
})

const PgAttrDef = table('pg_attrdef', {
  adrelid: column.oid().notNull(),
  adnum: column.integer().notNull(),
  adbin: column.text().notNull()
})

const inline = (sql: HasSql) => postgresDialect.inline(sql)

export const postgresDiff: Diff = (hasTable: Table) => {
  return txGenerator(function* (tx) {
    const tableApi = getTable(hasTable)
    const c = alias(PgClass, 'c')
    const n = alias(PgNamespace, 'n')
    const a = alias(PgAttribute, 'a')
    const t = alias(PgType, 't')
    const ad = alias(PgAttrDef, 'ad')
    const def = tx
      .select({
        table_name: c.relname,
        column_name: a.attname,
        column_idx: a.attnum,
        type: sql<string>`pg_catalog.format_type(${a.atttypid}, ${a.atttypmod})`,
        not_null: or(a.attnotnull, ne(a.attidentity, '')),
        def_val: when<string>([
          a.atthasdef,
          sql`pg_catalog.pg_get_expr(${ad.adbin}, ${ad.adrelid})`
        ]),
        identity: when<string>(
          [eq(a.attidentity, 'a'), sql`'generated always as identity'`],
          [eq(a.attidentity, 'd'), sql`'generated by default as identity'`]
        ),
        schema_name: n.nspname
      })
      .from(c)
      .innerJoin(n, eq(n.oid, c.relnamespace))
      .innerJoin(a, and(gt(a.attnum, 0), eq(a.attrelid, c.oid)))
      .innerJoin(t, eq(a.atttypid, t.oid))
      .leftJoin(ad, and(eq(a.attrelid, ad.adrelid), eq(a.attnum, ad.adnum)))
      .where(eq(c.relname, tableApi.name))
      .orderBy(asc(a.attnum))
      .as('def')
    const type = concat(
      when(
        [
          like(def.def_val, 'nextval(%_seq%'),
          when(
            def.type,
            ['integer', 'serial'],
            ['smallint', 'smallserial'],
            ['bigint', 'bigserial'],
            def.type
          )
        ],
        def.type
      ),
      when([isNotNull(def.identity), concat(' ', def.identity)], '')
    ).inlineValues()
    const isSequence = and(
      like(def.def_val, 'nextval(%_seq%'),
      or(
        eq(def.type, 'integer'),
        eq(def.type, 'smallint'),
        eq(def.type, 'bigint')
      )
    )
    const dflt_value = when(
      [and(isNotNull(def.def_val), not(isSequence)), def.def_val],
      ''
    ).inlineValues()
    const columnInfo = yield* tx
      .select({
        name: def.column_name,
        type,
        notnull: def.not_null,
        dflt_value
      })
      .from(def)
    console.log(columnInfo)
    /*const localColumns = new Map(
      columnInfo.map(column => {
        return [
          column.name,
          inline(
            sql.chunk('emitColumn', {
              type: sql.unsafe(column.type.toLowerCase()),
              notNull: column.notNull
            })
          )
        ]
      })
    )
    console.log(localColumns)*/
    return []
  })
}
